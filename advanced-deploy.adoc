## Zero-downtime Deployments in Production

In this lab you will learn how to roll out new releases to production without impacting the users of your application.

### Background
*Zero downtime* means that even during a deployment process, your service is responsive the whole time. Typical services in today's world are some HTTP services, so in practice this means that no requests are dropped at any point during the deployment process. During a typical deployment process we usually change our software to a newer version on the servers.

OpenShift provides an easy way to do *Blue/Green deployments*. Blue/Green deployments is a technique for **releasing your application** in a **predictable** manner with a goal of **reducing any downtime associated with a release**. It's a quick way to prime your app before releasing, and also quickly roll back if you find issues.

Simply, you have two identical environments (infrastructure) with the “green” environment hosting the current production apps. and the "blue environment" ready to accept new versions of the application. In this environment you deploy the new version of the application, run smoke tests, and any other tests (including those to exercise/prime the OS, cache, CPU, etc). When things look good, you change the loadbalancer/reverse proxy/router to point to the blue environment.

You monitor for any failures or exceptions because of the release. If everything looks good, you can eventually shut down the green environment and use it to stage any new releases. If not, you can quickly rollback to the green environment by pointing the loadbalancer back.

image::devops-zerodowntime-bluegreen.png[Blue/Green deployments]

*Canary releases* are a way of sending out a new version of your application into production that plays the role of a “canary” to get an idea of how it will perform (integrate with other apps, CPU, memory, disk usage, etc). It’s another release strategy that can mitigate the fact that regardless of the immense level of testing you do in lower environments you will still have some bugs in production. Canary releases let you test the waters before pulling the trigger on a full release. 

Similarly to a Blue/Green deployment, you'll have two versions of your application deployed, but in this scenario, both will accept load indistincly. The amount of load you send to the Canary initially is very low, but one can increase it with time to gain confidence. Eventually, the canary side will assume the 100% of the load, and the old version could be safely retired, or kept in place for a quick rollback in case required.

A canary release is used to get faster feedback without impacting all of the users of the application so you can fail the deployment faster, or proceed cautiously.

image::devops-zerodowntime-canary.png[Canary release]

We are going to release a new version of our application using a Canary release.

### Configure your canary release

Let's create our Pipeline that will drive the canary release process.

Change to the `cd-infra` repository working copy on your workstation:

[source,shell,role=copypaste]
----
cd cd-infra
----


Create the Jenkinsfile for canary release of Catalog to the PROD environment:

[source,shell,role=copypaste]
----
cat <<'EOF' > Jenkinsfile.catalog-prod
def namespace, releaseTag, prodCluster, prodToken, activeSvc, canarySvc

pipeline {
  agent {
      label 'skopeo'
  }
  stages {
    stage('Choose Release Version') {
      steps {
        script {
          openshift.withCluster() {
            namespace = openshift.project()
            prodCluster = env.PROD_MASTER.replace("https://","insecure://")
            withCredentials([usernamePassword(credentialsId: "${namespace}-prod-credentials", usernameVariable: "PROD_USER", passwordVariable: "PROD_TOKEN")]) {
              prodToken = env.PROD_TOKEN
            }
            def tags = openshift.selector("istag").objects().collect { it.metadata.name }.findAll { it.startsWith 'catalog:' }.collect { it.replaceAll(/catalog:(.*)/, "\$1") }.sort()
            timeout(5) {
              releaseTag = input(
                ok: "Deploy",
                message: "Enter release version to promote to PROD",
                parameters: [
                  choice(choices: tags.join('\n'), description: '', name: 'Release Version')
                ]
              )
            }
          }
        }
      }
    }
    stage('Push Image to PROD') {
      steps {
        script {
          openshift.withCluster() {
            def srcCatalogRef = openshift.selector("istag", "catalog:${releaseTag}").object().image.dockerImageReference
            def destCatalogRef = "${env.PROD_REGISTRY}/${env.PROD_PROJECT}/catalog:${releaseTag}"
            def srcToken = readFile "/run/secrets/kubernetes.io/serviceaccount/token"
            sh "skopeo copy docker://${srcCatalogRef} docker://${destCatalogRef} --src-creds openshift:${srcToken} --dest-creds openshift:${prodToken} --src-tls-verify=false --dest-tls-verify=false"
          }
        }
      }
    }
    stage('Deploy Canary 10%') {
      steps {
        script {
          openshift.withCluster(prodCluster, prodToken) {
            openshift.withProject(env.PROD_PROJECT) {
              activeSvc = openshift.selector("route", "catalog").object().spec.to.name
              def suffix = (activeSvc ==~ /catalog-(\d+)/) ? (activeSvc.replaceAll(/catalog-(\d+)/, '$1') as int) + 1 : "1"
              canarySvc = "catalog-${suffix}"

              def template = 'https://raw.githubusercontent.com/openshift-labs/devops-oab-labs/master/openshift/catalog-deployment-template.yaml'
              openshift.apply(
                openshift.process("-f", template, "-p", "IMAGE_VERSION=${releaseTag}", "-p", "APP_NAME=${canarySvc}", "-l", "deployment=${canarySvc}")
              )
              openshift.set("route-backends", "catalog", "${activeSvc}=90%", "${canarySvc}=10%")
            }
          }
        }
      }
    }
    stage('Grow Canary 50%') {
      steps {
        timeout(time:15, unit:'MINUTES') {
            input message: "Send 50% of live traffic to new release?", ok: "Approve"
        }
        script {
          openshift.withCluster(prodCluster, prodToken) {
            openshift.withProject(env.PROD_PROJECT) {
              openshift.set("route-backends", "catalog", "${activeSvc}=50%", "${canarySvc}=50%")
            }
          }
        }
      }
    }
    stage('Rollout 100%') {
      steps {
        timeout(time:15, unit:'MINUTES') {
            input message: "Send 100% of live traffic to the new release?", ok: "Approve"
        }
        script {
          openshift.withCluster(prodCluster, prodToken) {
            openshift.withProject(env.PROD_PROJECT) {
              openshift.set("route-backends", "catalog", "${canarySvc}=100%")
              openshift.selector(["dc/${activeSvc}", "svc/${activeSvc}"]).delete()
            }
          }
        }
      }
    }
  }
  post { 
    aborted {
      script {
        openshift.withCluster(prodCluster, prodToken) {
          openshift.withProject(env.PROD_PROJECT) {
            echo "Rolling back to current release ${activeSvc} and deleting the canary"
            openshift.set("route-backends", "catalog", "${activeSvc}=100%")
            openshift.selector(["dc/${canarySvc}", "svc/${canarySvc}"]).delete()
          }
        }
      }
    }
    failure { 
      script {
        openshift.withCluster(prodCluster, prodToken) {
          openshift.withProject(env.PROD_PROJECT) {
            echo "Rolling back to current release ${activeSvc} and deleting the canary"
            openshift.set("route-backends", "catalog", "${activeSvc}=100%")
            openshift.selector(["dc/${canarySvc}", "svc/${canarySvc}"]).delete()
          }
        }
      }
    }
  }
}
EOF
----

Add the Jenkinsfile to `cd-infra` git repository:

[source,shell,role=copypaste]
----
git add Jenkinsfile.catalog-prod
git commit -m "catalog deploy prod pipeline added"
git push origin master
----

You should now see your `cd-infra` repository with all the pipelines we have created.

image::devops-zerodowntime-gogs-pipelines.png[Pipelines in Gogs]

Now, let's create a new Pipeline build in OpenShift that will use this Jenkins file.

Like before, on you `cicd{{PROJECT_SUFFIX}}` project, click on *Add to project -> Import YAML/JSON* menu and enter the following definition:

CAUTION: In the following url(s), replace `GUID` with the guid provided to you.

[source,shell,role=copypaste]
----
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: catalog-deploy-prod
spec:
  runPolicy: Serial
  source:
    git:
      ref: master
      uri: "http://{{GIT_HOSTNAME}}/{{GIT_USER}}/cd-infra.git"
    type: Git
  strategy:
    jenkinsPipelineStrategy:
      env:
        - name: PROD_REGISTRY
          value: "{{ PROD_REGISTRY }}"
        - name: PROD_MASTER
          value: "{{ PROD_URL }}"
        - name: PROD_PROJECT
          value: "prod{{ PROJECT_SUFFIX }}"
      jenkinsfilePath: Jenkinsfile.catalog-prod
    type: JenkinsPipeline
----

You should now see the pipeline being executed and the canary release rolling out.

TODO: Image of the process
